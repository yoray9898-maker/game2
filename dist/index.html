<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>元素戰爭：操作精修版</title>
    <style>
        * { -webkit-tap-highlight-color: transparent; outline: none; box-sizing: border-box; }
        body { display: flex; flex-direction: column; align-items: center; background-color: #2c3e50; color: white; font-family: 'Microsoft JhengHei', Arial, sans-serif; margin: 0; padding-top: 10px; overflow: hidden; touch-action: none; }
        
        /* UI 面板 */
        .ui-panel { display: flex; justify-content: space-between; background: #34495e; padding: 10px 15px; width: 100%; max-width: 610px; border-radius: 4px; margin-bottom: 10px; box-shadow: 0 4px 0 rgba(0,0,0,0.2); }
        .stat-box { text-align: center; flex: 1; }
        .label { font-size: 0.8em; color: #bdc3c7; display: block; }
        .stat { font-size: 1.1em; font-weight: bold; color: #f1c40f; }

        /* 遊戲畫面 */
        #game-container { position: relative; width: 600px; height: 400px; max-width: 100vw; }
        canvas { background-color: #ecf0f1; border: 4px solid #34495e; border-radius: 4px; display: block; width: 100%; height: 100%; object-fit: contain; }

        /* 難度選擇 */
        .overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(44, 62, 80, 0.98); display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 100; border-radius: 4px; }
        .diff-btn { width: 90%; max-width: 450px; padding: 12px; margin: 6px; border: none; border-radius: 12px; color: white; cursor: pointer; text-align: left; }
        .diff-btn b { font-size: 1.1em; display: block; }
        .diff-btn span { font-size: 0.85em; opacity: 0.9; }

        /* 下方商店：強制單排 */
        .controls { 
            margin-top: 10px; 
            display: flex; 
            flex-direction: row; /* 強制橫向 */
            flex-wrap: nowrap;   /* 不換行 */
            overflow-x: auto;    /* 超出時可橫移 */
            width: 100%; 
            max-width: 610px; 
            background: #34495e; 
            padding: 10px 5px; 
            border-radius: 4px; 
            gap: 5px; 
            scrollbar-width: none; /* 隱藏滾動條 (Firefox) */
        }
        .controls::-webkit-scrollbar { display: none; } /* 隱藏滾動條 (Chrome) */

        .shop-btn { 
            flex: 0 0 auto; /* 不壓縮，維持內容寬度 */
            padding: 10px 8px; 
            min-width: 75px; 
            cursor: pointer; 
            border: 2px solid transparent; 
            border-radius: 4px; 
            color: white; 
            font-weight: bold; 
            font-size: 0.75em; 
            text-align: center; 
            transition: 0.1s; 
        }
        .shop-btn.selected { border: 2px solid #f1c40f; transform: translateY(-5px); background-color: #445566 !important; box-shadow: 0 4px 8px rgba(0,0,0,0.5); }
        
        /* 升級選單 */
        #upgradeMenu { background: #8e44ad; padding: 15px; border-radius: 10px; display: none; gap: 10px; align-items: center; border: 2px solid #f1c40f; margin-top: 10px; width: 100%; max-width: 610px; justify-content: center; flex-wrap: wrap; }
        .hidden { display: none !important; }
    </style>
</head>
<body>

    <div class="ui-panel">
        <div class="stat-box"><span class="label">金錢</span><span id="money" class="stat">200</span></div>
        <div class="stat-box"><span class="label">生命</span><span id="health" class="stat">20</span></div>
        <div class="stat-box"><span class="label">波次</span><span id="waveDisplay" class="stat">1</span></div>
        <div class="stat-box"><span class="label">核彈</span><span id="nukeDisplay" class="stat">0</span></div>
    </div>

    <div id="game-container">
        <div id="start-screen" class="overlay">
            <h2 style="color:#f1c40f; margin-bottom: 15px;">請選擇難度</h2>
            <button class="diff-btn" style="background:#27ae60;" onclick="startGame(1.25, 1.0)">
                <b>簡單 (Easy)</b>
                <span>金錢獲取: 100% / 敵人血量成長: 1.25x</span>
            </button>
            <button class="diff-btn" style="background:#2980b9;" onclick="startGame(1.30, 1.2)">
                <b>普通 (Normal)</b>
                <span>金錢獲取: 120% / 敵人血量成長: 1.30x</span>
            </button>
            <button class="diff-btn" style="background:#c0392b;" onclick="startGame(1.40, 1.4)">
                <b>困難 (Hard)</b>
                <span>金錢獲取: 140% / 敵人血量成長: 1.40x</span>
            </button>
        </div>
        <canvas id="gameCanvas" width="600" height="400"></canvas>
    </div>

    <div id="upgradeMenu">
        <span id="towerInfo" style="width: 100%; text-align: center; font-weight: bold; color: #f1c40f;"></span>
        <button style="background:#f1c40f; border:none; padding:10px 15px; border-radius:5px; font-weight:bold;" onclick="upgradeSelectedTower()">升級 $<span id="upgradeCost"></span></button>
        <button style="background:#EA0000; color:white; border:none; padding:10px 15px; border-radius:5px;" onclick="sellSelectedTower()">賣出</button>
        <button style="background:#bdc3c7; border:none; padding:10px 15px; border-radius:5px;" onclick="deselectTower()">取消</button>
    </div>

    <div class="controls" id="shopControls">
        <button class="shop-btn" id="btn-gun" style="background:#2980b9" onclick="selectType('gun')">機槍 $50</button>
        <button class="shop-btn" id="btn-ice" style="background:#3498db" onclick="selectType('ice')">寒冰 $80</button>
        <button class="shop-btn" id="btn-bomb" style="background:#d35400" onclick="selectType('bomb')">砲擊 $120</button>
        <button class="shop-btn" id="btn-summon" style="background:#f1c40f; color:#2c3e50;" onclick="selectType('summon')">召喚 $150</button>
        <button class="shop-btn" id="btn-trap" style="background:#7f8c8d" onclick="selectType('trap')">陷阱 $150</button>
        <button class="shop-btn" id="btn-nuke" style="background:#c0392b;" onclick="useNuke()">核彈 $500</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let money = 200, health = 20, currentWave = 1, gameRunning = false;
        let towers = [], enemies = [], bullets = [], soldiers = [], fieldTraps = [], damageTexts = [];
        let currentType = null, selectedTower = null, mousePos = {x:-1, y:-1}, isTouchingField = false;
        let hpGrowth = 1.3, moneyMult = 1.0;
        let nukeCount = 0, enemiesToSpawn = 0, spawnTimer = 0, waveInProgress = false;

        const pathPoints = [{x:0,y:1},{x:4,y:1},{x:4,y:4},{x:2,y:4},{x:2,y:6},{x:7,y:6},{x:7,y:2},{x:13,y:2},{x:13,y:5},{x:10,y:5},{x:10,y:7},{x:14,y:7}];
        const mapLayout = [[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[1,1,1,1,1,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,1,0,0,1,1,1,1,1,1,1,0],[0,0,0,0,1,0,0,1,0,0,0,0,0,1,0],[0,0,1,1,1,0,0,1,0,0,0,0,0,1,0],[0,0,1,0,0,0,0,1,0,0,1,1,1,1,0],[0,0,1,1,1,1,1,1,0,0,1,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,1,1,1,1,1],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]];
        const roadTiles = []; for(let y=0;y<10;y++) for(let x=0;x<15;x++) if(mapLayout[y][x]===1) roadTiles.push({x,y});

        const towerProps = { 
            gun:[140,25,18,'#2980b9',50,"機槍塔"], ice:[120,15,35,'#3498db',80,"寒冰塔"], 
            bomb:[170,60,65,'#d35400',120,"砲擊塔"], summon:[0,150,360,'#f1c40f',150,"召喚塔"], 
            trap:[0,25,300,'#7f8c8d',150,"陷阱塔"] 
        };

        function startGame(rate, mMult) { 
            hpGrowth = rate; moneyMult = mMult; 
            document.getElementById('start-screen').style.display = 'none';
            gameRunning = true; waveInProgress = true; enemiesToSpawn = 5; 
            updateUI(); requestAnimationFrame(gameLoop); 
        }

        function updateCoords(e) {
            e.preventDefault(); 
            const rect = canvas.getBoundingClientRect();
            let cx = e.clientX, cy = e.clientY;
            if(e.touches && e.touches[0]) { cx = e.touches[0].clientX; cy = e.touches[0].clientY; }
            const sx = canvas.width / rect.width, sy = canvas.height / rect.height;
            mousePos.x = Math.floor(((cx - rect.left) * sx) / 40);
            mousePos.y = Math.floor(((cy - rect.top) * sy) / 40);
        }

        canvas.addEventListener('pointerdown', (e) => { isTouchingField = true; updateCoords(e); });
        canvas.addEventListener('pointermove', (e) => { if(isTouchingField) updateCoords(e); });
        canvas.addEventListener('pointerup', (e) => {
            isTouchingField = false;
            updateCoords(e);
            const px = mousePos.x, py = mousePos.y;
            if (px < 0 || px >= 15 || py < 0 || py >= 10) return;
            const existing = towers.find(t => Math.floor(t.x/40) === px && Math.floor(t.y/40) === py);
            if(existing) {
                selectedTower = existing; currentType = null;
                document.querySelectorAll('.shop-btn').forEach(b => b.classList.remove('selected'));
                toggleMode('upgrade'); updateUpgradeUI();
            } else if (currentType && mapLayout[py][px] === 0) {
                if (money >= towerProps[currentType][4]) {
                    towers.push({ x: px*40, y: py*40, type: currentType, level: 1, range: towerProps[currentType][0], dmg: towerProps[currentType][1], cd: 0, cdMax: towerProps[currentType][2], color: towerProps[currentType][3], freezeTimer: 0 });
                    money -= towerProps[currentType][4]; updateUI();
                }
            } else { deselectTower(); }
        });

        class Enemy {
            constructor(wave) { 
                this.x = pathPoints[0].x*40; this.y = pathPoints[0].y*40; this.tIdx = 1; 
                this.maxHp = 100 * Math.pow(hpGrowth, wave-1); this.hp = this.maxHp; 
                this.isBoss = wave % 5 === 0; this.baseSpeed = 1.2; this.flash = 0; this.stun = 0;
                this.slows = new Map(); this.bossFreezeCd = 240; this.berserk = false; this.berserkTimer = 0;
            }
            update() {
                if(this.flash > 0) this.flash--;
                if(this.isBoss) {
                    if(this.hp/this.maxHp < 0.3 && !this.berserk) { this.berserk = true; this.berserkTimer = 150; }
                    if(--this.bossFreezeCd <= 0) { if(towers.length > 0) towers[Math.floor(Math.random()*towers.length)].freezeTimer = 180; this.bossFreezeCd = 240; }
                }
                if(this.berserkTimer > 0) { this.berserkTimer--; this.stun = 0; }
                if(this.stun > 0) { this.stun--; return; }
                let totalSlow = 0;
                let sorted = Array.from(this.slows.values()).sort((a,b)=>b-a);
                if(sorted.length > 0) { totalSlow = sorted[0]; for(let i=1;i<sorted.length;i++) totalSlow += sorted[i]*0.02; }
                let speed = (this.baseSpeed * (1 - Math.min(totalSlow, this.isBoss?0.5:0.75))) * (this.berserk?2:1);
                let tgt = pathPoints[this.tIdx];
                let dx = tgt.x*40-this.x, dy = tgt.y*40-this.y, d = Math.sqrt(dx*dx+dy*dy);
                if(d < 2) { this.tIdx++; if(this.tIdx>=pathPoints.length) { health--; this.hp=0; updateUI(); } }
                else { this.x += (dx/d)*speed; this.y += (dy/d)*speed; }
                this.slows.clear();
            }
            draw() {
                ctx.fillStyle = this.stun > 0 ? "#74b9ff" : (this.flash > 0 ? "white" : (this.isBoss ? (this.berserk?"#ff0000":"#8e44ad") : "#c0392b"));
                ctx.beginPath(); ctx.arc(this.x+20, this.y+20, this.isBoss?18:12, 0, Math.PI*2); ctx.fill();
                let pct = Math.max(0, this.hp/this.maxHp);
                ctx.fillStyle = "rgba(0,0,0,0.5)"; ctx.fillRect(this.x+(this.isBoss?0:8), this.y-10, this.isBoss?40:24, 5);
                ctx.fillStyle = pct > 0.5 ? "#2ecc71" : "#e74c3c"; ctx.fillRect(this.x+(this.isBoss?0:8), this.y-10, (this.isBoss?40:24)*pct, 5);
            }
        }

        function gameLoop() {
            if(!gameRunning) return; ctx.clearRect(0,0,600,400);
            for(let y=0;y<10;y++) for(let x=0;x<15;x++) { ctx.fillStyle = mapLayout[y][x]===1 ? '#d35400' : '#27ae60'; ctx.fillRect(x*40,y*40,40,40); }

            // 僅在觸摸場地且有選塔時顯示預覽圈
            if (isTouchingField && currentType && !selectedTower) {
                if(mousePos.y>=0 && mousePos.y<10 && mousePos.x>=0 && mousePos.x<15 && mapLayout[mousePos.y][mousePos.x]===0) {
                    ctx.fillStyle = "rgba(255,255,255,0.3)"; ctx.fillRect(mousePos.x*40,mousePos.y*40,40,40);
                }
                let r = towerProps[currentType][0];
                if(r > 0) {
                    ctx.beginPath(); ctx.arc(mousePos.x*40+20, mousePos.y*40+20, r, 0, Math.PI*2);
                    ctx.fillStyle = "rgba(255,255,255,0.15)"; ctx.fill(); ctx.strokeStyle = "white"; ctx.stroke();
                }
            } else if(selectedTower && selectedTower.range > 0) {
                ctx.beginPath(); ctx.arc(selectedTower.x+20, selectedTower.y+20, selectedTower.range, 0, Math.PI*2);
                ctx.fillStyle = "rgba(255,255,255,0.15)"; ctx.fill(); ctx.strokeStyle = "white"; ctx.stroke();
            }

            towers.forEach(t => {
                if(t.freezeTimer > 0) { t.freezeTimer--; ctx.fillStyle = "rgba(0,191,255,0.4)"; ctx.fillRect(t.x,t.y,40,40); }
                ctx.fillStyle = t.color; ctx.fillRect(t.x+2, t.y+2, 36, 36);
                ctx.fillStyle = "white"; ctx.font="10px Arial"; ctx.textAlign="center"; ctx.fillText("LV."+t.level, t.x+20, t.y+25);
                if(t.freezeTimer <= 0 && --t.cd <= 0) {
                    if(t.type==='summon') { soldiers.push({x:pathPoints[1].x*40+12,y:pathPoints[1].y*40+12,dmg:t.dmg}); t.cd=Math.max(120,360-(t.level-1)*60); }
                    else if(t.type==='trap') { let rt=roadTiles[Math.floor(Math.random()*roadTiles.length)]; fieldTraps.push({x:rt.x,y:rt.y,stun:Math.min(240,60+(t.level-1)*30)}); t.cd=Math.max(150,300-(t.level-1)*30); }
                    else { let tgt=enemies.find(e=>Math.hypot(e.x+20-(t.x+20), e.y+20-(t.y+20))<t.range); if(tgt) { bullets.push({x:t.x+20,y:t.y+20,target:tgt,dmg:t.dmg,tower:t}); t.cd=t.cdMax; } }
                }
            });

            bullets = bullets.filter(b => {
                let dx = b.target.x+20-b.x, dy = b.target.y+20-b.y, d = Math.sqrt(dx*dx+dy*dy);
                if(d < 15) {
                    let dmg = b.dmg, crit = false;
                    if(b.tower.type==='gun' && b.tower.level>=3 && Math.random()<(0.2+(b.tower.level-3)*0.04)) { dmg*=1.5; crit=true; }
                    if(b.tower.type==='bomb' && b.tower.level>=3) { enemies.forEach(e => { if(e!==b.target && Math.hypot(e.x-b.target.x, e.y-b.target.y)<60) e.hp-=b.dmg*0.5; }); ctx.strokeStyle="orange"; ctx.beginPath(); ctx.arc(b.target.x+20,b.target.y+20,60,0,Math.PI*2); ctx.stroke(); }
                    if(b.tower.type==='ice') b.target.slows.set(b.tower, (0.5+(b.tower.level-1)*0.02));
                    b.target.hp-=dmg; b.target.flash=3; damageTexts.push({x:b.x,y:b.y,txt:Math.floor(dmg),life:30,c:crit?"#ff0000":"white"}); return false;
                }
                b.x+=(dx/d)*10; b.y+=(dy/d)*10; ctx.fillStyle=b.tower.type==='ice'?"#74b9ff":"yellow"; ctx.beginPath(); ctx.arc(b.x,b.y,4,0,Math.PI*2); ctx.fill(); return b.target.hp>0;
            });

            fieldTraps = fieldTraps.filter(ft => {
                let hit = enemies.find(e => Math.hypot(e.x+20-(ft.x*40+20), e.y+20-(ft.y*40+20))<20);
                if(hit) { hit.stun = hit.isBoss?ft.stun*0.5:ft.stun; return false; }
                ctx.fillStyle="rgba(255,255,0,0.3)"; ctx.fillRect(ft.x*40+10,ft.y*40+10,20,20); return true;
            });

            soldiers = soldiers.filter(s => {
                let hit = enemies.find(e => Math.hypot(e.x+20-(s.x+8), e.y+20-(s.y+8))<25);
                if(hit) { hit.hp-=s.dmg; hit.flash=5; return false; }
                ctx.fillStyle="#bdc3c7"; ctx.fillRect(s.x,s.y,16,16); return true;
            });

            damageTexts.forEach(dt => { dt.y-=0.5; dt.life--; ctx.fillStyle=dt.c; ctx.fillText(dt.txt,dt.x,dt.y); });
            damageTexts = damageTexts.filter(dt => dt.life>0);

            if(waveInProgress) {
                if(enemiesToSpawn>0) { if(++spawnTimer>60) { enemies.push(new Enemy(currentWave)); enemiesToSpawn--; spawnTimer=0; } }
                else if(enemies.length===0) { waveInProgress=false; setTimeout(()=>{ currentWave++; enemiesToSpawn=5+currentWave; waveInProgress=true; updateUI(); }, 2000); }
            }
            enemies.forEach(e => { e.update(); e.draw(); });
            enemies = enemies.filter(e => { if(e.hp<=0) { money+=15*moneyMult; if(e.isBoss && Math.random()<0.5) nukeCount++; updateUI(); } return e.hp>0; });
            if(health<=0) { alert("Game Over!"); location.reload(); }
            requestAnimationFrame(gameLoop);
        }

        function selectType(t) { 
            if(currentType===t) deselectTower(); 
            else { selectedTower=null; currentType=t; document.querySelectorAll('.shop-btn').forEach(b=>b.classList.remove('selected')); document.getElementById('btn-'+t).classList.add('selected'); toggleMode('shop'); } 
        }
        function deselectTower() { selectedTower=null; currentType=null; document.querySelectorAll('.shop-btn').forEach(b=>b.classList.remove('selected')); toggleMode('shop'); }
        function toggleMode(m) { 
            document.getElementById('shopControls').style.display = m==='shop'?'flex':'none'; 
            document.getElementById('upgradeMenu').style.display = m==='upgrade'?'flex':'none'; 
        }
        function updateUpgradeUI() { let c = Math.floor(towerProps[selectedTower.type][4]*Math.pow(1.6,selectedTower.level)); document.getElementById('upgradeCost').innerText=c; document.getElementById('towerInfo').innerText=towerProps[selectedTower.type][5]+" LV."+selectedTower.level; }
        function upgradeSelectedTower() {
            let c = Math.floor(towerProps[selectedTower.type][4]*Math.pow(1.6,selectedTower.level));
            if(money>=c) { money-=c; selectedTower.level++; selectedTower.dmg*=1.7; if(selectedTower.range>0) selectedTower.range+=10; updateUI(); updateUpgradeUI(); }
        }
        function sellSelectedTower() { towers=towers.filter(t=>t!==selectedTower); money+=Math.floor(towerProps[selectedTower.type][4]*0.6); updateUI(); deselectTower(); }
        function updateUI() { document.getElementById('money').innerText=Math.floor(money); document.getElementById('health').innerText=health; document.getElementById('waveDisplay').innerText=currentWave; document.getElementById('nukeDisplay').innerText=nukeCount; document.getElementById('btn-nuke').innerText=`核彈(${nukeCount})`; }
        function useNuke() { if(nukeCount > 0 && money >= 500) { nukeCount--; money -= 500; enemies.forEach(e => { e.hp -= e.hp * (e.isBoss ? 0.5 : 0.75); e.flash = 10; }); updateUI(); } }
    </script>
</body>
</html>
